{
  "options": {
    "name": "Mr. Doc",
    "url": {
      "home": "https://mr-doc.github.io/",
      "repo": "https://www.github.com/mr-doc/mr-doc"
    }
  },
  "comments": [
  {
    "description": "Parse the CLI arguments.",
    "tags": [
      {
        "title": "static",
        "description": null,
        "lineNumber": 2
      }
    ],
    "loc": {
      "start": {
        "line": 20,
        "column": 2
      },
      "end": {
        "line": 23,
        "column": 5
      }
    },
    "context": {
      "code": "static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }",
      "file": {
        "id": "4JO5WbVCe",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\cli",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 24,
          "column": 2
        },
        "end": {
          "line": 31,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          24,
          31
        ]
      }
    }
  },
  {
    "description": "Create the CLI.",
    "tags": [
      {
        "title": "static",
        "description": null,
        "lineNumber": 2
      },
      {
        "title": "returns",
        "description": "An instance of Liftoff.",
        "lineNumber": 3,
        "type": {
          "type": "NameExpression",
          "name": "Liftoff"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 32,
        "column": 2
      },
      "end": {
        "line": 36,
        "column": 5
      }
    },
    "context": {
      "code": "static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }",
      "file": {
        "id": "4JO5WbVCe",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\cli",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 37,
          "column": 2
        },
        "end": {
          "line": 44,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          37,
          44
        ]
      }
    }
  },
  {
    "description": "Launch the cli.",
    "tags": [
      {
        "title": "static",
        "description": null,
        "lineNumber": 2
      },
      {
        "title": "param",
        "description": "The parsed CLI arguments.",
        "lineNumber": 3,
        "type": null,
        "name": "Object"
      },
      {
        "title": "returns",
        "description": "A promise to the stream.",
        "lineNumber": 4,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Promise"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Stream"
            }
          ]
        }
      }
    ],
    "loc": {
      "start": {
        "line": 45,
        "column": 2
      },
      "end": {
        "line": 50,
        "column": 5
      }
    },
    "context": {
      "code": "static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }",
      "file": {
        "id": "4JO5WbVCe",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\cli",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 51,
          "column": 2
        },
        "end": {
          "line": 61,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          51,
          61
        ]
      }
    }
  },
  {
    "description": "Handles the result from the CLI.",
    "tags": [
      {
        "title": "static",
        "description": null,
        "lineNumber": 2
      }
    ],
    "loc": {
      "start": {
        "line": 62,
        "column": 2
      },
      "end": {
        "line": 65,
        "column": 5
      }
    },
    "context": {
      "code": "static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }",
      "file": {
        "id": "4JO5WbVCe",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\cli",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 66,
          "column": 2
        },
        "end": {
          "line": 115,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          66,
          115
        ]
      }
    }
  },
  {
    "description": "Get the global instance of Log.",
    "tags": [
      {
        "title": "returns",
        "description": "An instance of Log.",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "Log"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 45,
        "column": 2
      },
      "end": {
        "line": 48,
        "column": 5
      }
    },
    "context": {
      "code": "static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }",
      "file": {
        "id": "V1mu9WbVAx",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\utils",
          "base": "log.js",
          "ext": ".js",
          "name": "log"
        },
        "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 49,
          "column": 2
        },
        "end": {
          "line": 52,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          49,
          52
        ]
      }
    }
  },
  {
    "description": "",
    "tags": [
      {
        "title": "class",
        "description": null,
        "lineNumber": 1,
        "type": null,
        "name": null
      },
      {
        "title": "param",
        "description": "The options for the compiler provided by mr-doc-utils/options",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      }
    ],
    "loc": {
      "start": {
        "line": 3,
        "column": 2
      },
      "end": {
        "line": 6,
        "column": 5
      }
    },
    "context": {
      "code": "constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }",
      "file": {
        "id": "NJLOqb-VRx",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\compiler\\compilers",
          "base": "interface.js",
          "ext": ".js",
          "name": "interface"
        },
        "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 7,
          "column": 2
        },
        "end": {
          "line": 9,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          7,
          9
        ]
      }
    }
  },
  {
    "description": "Compile the comments into the desired output.",
    "tags": [
      {
        "title": "param",
        "description": "The files to compile.",
        "lineNumber": 2,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Object"
            }
          ]
        },
        "name": "results"
      },
      {
        "title": "returns",
        "description": "The compiled files.",
        "lineNumber": 3,
        "type": {
          "type": "AllLiteral"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 10,
        "column": 2
      },
      "end": {
        "line": 14,
        "column": 5
      }
    },
    "context": {
      "code": "compile(comments) {\n    // ...\n  }",
      "file": {
        "id": "NJLOqb-VRx",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\compiler\\compilers",
          "base": "interface.js",
          "ext": ".js",
          "name": "interface"
        },
        "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 16,
          "column": 2
        },
        "end": {
          "line": 18,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          16,
          18
        ]
      }
    }
  },
  {
    "description": "",
    "tags": [
      {
        "title": "class",
        "description": null,
        "lineNumber": 1,
        "type": null,
        "name": null
      },
      {
        "title": "param",
        "description": "The options for the compiler provided by mr-doc-utils/options",
        "lineNumber": 2,
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      }
    ],
    "loc": {
      "start": {
        "line": 3,
        "column": 2
      },
      "end": {
        "line": 6,
        "column": 5
      }
    },
    "context": {
      "code": "constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }",
      "file": {
        "id": "V1duq--V0g",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\parser\\parsers",
          "base": "interface.js",
          "ext": ".js",
          "name": "interface"
        },
        "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 7,
          "column": 2
        },
        "end": {
          "line": 9,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          7,
          9
        ]
      }
    }
  },
  {
    "description": "Parses the sources' comments into the desired output.",
    "tags": [
      {
        "title": "param",
        "description": "The files to parse.",
        "lineNumber": 2,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Object"
            }
          ]
        },
        "name": "results"
      },
      {
        "title": "returns",
        "description": "The parsed comments.",
        "lineNumber": 3,
        "type": {
          "type": "TypeApplication",
          "expression": {
            "type": "NameExpression",
            "name": "Array"
          },
          "applications": [
            {
              "type": "NameExpression",
              "name": "Object"
            }
          ]
        }
      }
    ],
    "loc": {
      "start": {
        "line": 10,
        "column": 2
      },
      "end": {
        "line": 14,
        "column": 5
      }
    },
    "context": {
      "code": "parse(sources) {\n    // ...\n  }",
      "file": {
        "id": "V1duq--V0g",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\parser\\parsers",
          "base": "interface.js",
          "ext": ".js",
          "name": "interface"
        },
        "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 16,
          "column": 2
        },
        "end": {
          "line": 18,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          16,
          18
        ]
      }
    }
  },
  {
    "description": "Parse the file.",
    "tags": [
      {
        "title": "param",
        "description": "The file to parse.",
        "lineNumber": 2,
        "type": null,
        "name": "Object"
      }
    ],
    "loc": {
      "start": {
        "line": 19,
        "column": 2
      },
      "end": {
        "line": 22,
        "column": 5
      }
    },
    "context": {
      "code": "parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }",
      "file": {
        "id": "Nksu5--VRl",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\parser\\parsers\\javascript",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 23,
          "column": 2
        },
        "end": {
          "line": 34,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          23,
          34
        ]
      }
    }
  },
  {
    "description": "Walk the comments.",
    "tags": [
      {
        "title": "param",
        "description": "The comment type and context to walk.",
        "lineNumber": 2,
        "type": null,
        "name": "Object"
      }
    ],
    "loc": {
      "start": {
        "line": 35,
        "column": 2
      },
      "end": {
        "line": 38,
        "column": 5
      }
    },
    "context": {
      "code": "walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }",
      "file": {
        "id": "Nksu5--VRl",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\parser\\parsers\\javascript",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 39,
          "column": 2
        },
        "end": {
          "line": 43,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          39,
          43
        ]
      }
    }
  },
  {
    "description": "Parse the comment.",
    "tags": [
      {
        "title": "param",
        "description": "The current node.",
        "lineNumber": 2,
        "type": null,
        "name": "Node"
      },
      {
        "title": "param",
        "description": "The truth value on whether to include the context.",
        "lineNumber": 3,
        "type": null,
        "name": "Boolean"
      }
    ],
    "loc": {
      "start": {
        "line": 44,
        "column": 2
      },
      "end": {
        "line": 48,
        "column": 5
      }
    },
    "context": {
      "code": "parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }",
      "file": {
        "id": "Nksu5--VRl",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\parser\\parsers\\javascript",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 49,
          "column": 2
        },
        "end": {
          "line": 76,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          49,
          76
        ]
      }
    }
  },
  {
    "description": "Parse the JSDoc comment.",
    "tags": [
      {
        "title": "param",
        "description": "The comment to parse.",
        "lineNumber": 2,
        "type": null,
        "name": "String"
      },
      {
        "title": "param",
        "description": "The comment location.",
        "lineNumber": 3,
        "type": null,
        "name": "Location"
      },
      {
        "title": "param",
        "description": "The truth value on whether to include the context.",
        "lineNumber": 4,
        "type": null,
        "name": "Boolean"
      }
    ],
    "loc": {
      "start": {
        "line": 77,
        "column": 2
      },
      "end": {
        "line": 82,
        "column": 5
      }
    },
    "context": {
      "code": "parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }",
      "file": {
        "id": "Nksu5--VRl",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\parser\\parsers\\javascript",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 83,
          "column": 2
        },
        "end": {
          "line": 104,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          83,
          104
        ]
      }
    }
  },
  {
    "description": "Determine whether the comment is normalized.",
    "tags": [
      {
        "title": "param",
        "description": "The comment to determine.",
        "lineNumber": 2,
        "type": null,
        "name": "String"
      },
      {
        "title": "returns",
        "description": "The truth value.",
        "lineNumber": 3,
        "type": {
          "type": "NameExpression",
          "name": "Boolean"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 105,
        "column": 2
      },
      "end": {
        "line": 109,
        "column": 5
      }
    },
    "context": {
      "code": "isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }",
      "file": {
        "id": "Nksu5--VRl",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\parser\\parsers\\javascript",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 110,
          "column": 2
        },
        "end": {
          "line": 115,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          110,
          115
        ]
      }
    }
  },
  {
    "description": "Normalize the comment tags.",
    "tags": [
      {
        "title": "param",
        "description": "The comment to normalize.",
        "lineNumber": 2,
        "type": null,
        "name": "Array"
      },
      {
        "title": "returns",
        "description": "The comment containing normalized tags.",
        "lineNumber": 3,
        "type": {
          "type": "NameExpression",
          "name": "Array"
        }
      }
    ],
    "loc": {
      "start": {
        "line": 116,
        "column": 2
      },
      "end": {
        "line": 120,
        "column": 5
      }
    },
    "context": {
      "code": "static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }",
      "file": {
        "id": "Nksu5--VRl",
        "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
        "base": "src\\",
        "path": {
          "root": "",
          "dir": "src\\parser\\parsers\\javascript",
          "base": "index.js",
          "ext": ".js",
          "name": "index"
        },
        "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n",
        "ref": [
          {
            "4JO5WbVCe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\cli",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "/* eslint-env node */\n'use strict';\n\nconst Extension = require('../utils/extension');\nconst File = require('fs-extra');\nconst Log = require('../utils/log');\nconst Liftoff = require('liftoff');\nconst Option = require('mr-doc-utils').Option;\nconst Path = require('path');\nconst Promise = require('bluebird');\nconst Yargs = require('yargs');\nconst ViynlFS = require('vinyl-fs');\nconst isGlob = require('is-glob');\nconst log = Log.global();\nconst pkg = require('../../package.json');\nconst rc = require('rc');\nconst _ = require('lodash');\n\nclass CLI {\n  /**\n   * Parse the CLI arguments.\n   * @static\n   */\n  static parse() {\n    return Yargs\n    .usage('Usage: mrdoc [options]', Option.cli())\n    .showHelpOnFail(false, 'Specify --help for available options')\n    .help('help', log.color.gray('Show help.'))\n    .alias('help', 'h')\n    .argv;\n  }\n  /**\n   * Create the CLI.\n   * @static\n   * @return {Liftoff} - An instance of Liftoff.\n   */\n  static get rocket() {\n    // Create the CLI.\n    return new Liftoff({\n      name: 'mrdoc',\n      processTitle: 'mrdoc',\n      v8flags: require('v8flags'),\n    });\n  }\n  /**\n   * Launch the cli.\n   * @static\n   * @param {Object} - The parsed CLI arguments.\n   * @return {Promise<Stream>} - A promise to the stream.\n   */\n  static launch(argv) {\n    return new Promise((resolve, reject) => {\n      // Launch the CLI!\n      CLI.rocket.launch({\n        cwd: argv.cwd,\n        configPath: argv.mrdocrc,\n      }, env => CLI.handler(env, argv)\n      .then(stream => resolve(stream))\n      .catch(error => reject(error)));\n    });\n  }\n  /**\n   * Handles the result from the CLI.\n   * @static\n   */\n  static handler(env, options) {\n    const version = options.version || options.v;\n    const source = options.source || options.s;\n    if (version) {\n      log.info(`${log.color.blue('version:')} ${pkg.version}`);\n      process.exit();\n    }\n    if (_.isEmpty(source) && version === false) {\n      log.warn(`${log.color.yellow('No source specified!')} See --help for usage.`);\n      process.exit();\n    }\n    return new Promise((resolve, reject) => {\n      // Get the options.\n      const opts = rc('mrdoc', Option.merge(options));\n      const sources = opts.mrdoc.source.split(',')\n      .map(path => path.trim())\n      .map(path => {\n        // Check if the path is not in glob pattern.\n        if (!isGlob(path)) {\n          // Make sure the path is resolved.\n          let str = Path.resolve(opts.mrdoc.cwd, path).replace('/', Path.sep);\n          // Check if the path is a file or directory.\n          if (_.isEmpty(Path.parse(path).ext)) {\n            // Check if the path has a '/' at the end.\n            str = str[str.length - 1] === Path.sep ?\n            str : `${str}${Path.sep}`;\n          }\n          // Make sure the file or directory exists;\n          if (File.existsSync(str)) {\n            // Check if the directory has sub-directories.\n            const hasSubDirs = File.readdirSync(str)\n            .filter(file =>\n              File.statSync(Path.join(str, file)).isDirectory()).length > 1;\n            // Get the file extension.\n            const extension = Extension.find(opts.parser.language);\n            // Set the glob pattern based on 'hasSubDirs'.\n            str = hasSubDirs ?\n            `${str}**${Path.sep}*${extension}` : `${str}*${extension}`;\n          } else return null;\n          return str;\n        }\n        return path;\n      });\n      // DEBUG: Sources\n      log.debug(log.color.blue('Sources:'), sources);\n      if (sources.indexOf(null) > -1) {\n        reject(`${_.isArray(sources) ? sources.join(', ') : sources} does not exist!`);\n      } else resolve({ stream: ViynlFS.src(sources, { cwd: opts.mrdoc.cwd }), options: opts });\n    });\n  }\n}\n\nmodule.exports = CLI;\n"
            }
          },
          {
            "NJx_9bbECl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JSONC = require('./compilers/json/');\r\n// const HTML = require('./compilers/html');\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.compiler().file.format) {\r\n      case 'json':\r\n        return (new JSONC(this.options));\r\n      case 'html':\r\n        // return (new HTML(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Compiler;\r\n"
            }
          },
          {
            "Ny-d5W-EAe": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\r\nconst JavaScript = require('./parsers/javascript/');\r\n\r\nclass Parser {\r\n  constructor(options) {\r\n    this.options = options;\r\n  }\r\n  factory() {\r\n    switch (this.options.parser().language) {\r\n      case 'js':\r\n      case 'javascript':\r\n        return (new JavaScript(this.options));\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n}\r\nmodule.exports = Parser;\r\n"
            }
          },
          {
            "4kz_cWWVRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "extension.js",
                "ext": ".js",
                "name": "extension"
              },
              "source": "'use strict';\r\n\r\nclass Extension {\r\n  static find(language) {\r\n    return Extension.extensions()[language];\r\n  }\r\n  static extensions() {\r\n    return {\r\n      js: '.js',\r\n      javascript: '.js',\r\n      json: '.json',\r\n      html: '.html',\r\n      typescript: '.ts',\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = Extension;\r\n"
            }
          },
          {
            "V1mu9WbVAx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "log.js",
                "ext": ".js",
                "name": "log"
              },
              "source": "/* eslint-env node */\r\n'use strict';\r\n\r\n/* eslint-env node */\r\nconst Utils = require('mr-doc-utils');\r\nconst log = new Utils.Log();\r\nconst _ = require('lodash');\r\n\r\nclass Log {\r\n  constructor(options) {\r\n    if (options.silent) {\r\n      log.on('error', () => { /* NOOP */});\r\n      return log;\r\n    }\r\n    this.levels(options.level)\r\n    .forEach(level => {\r\n      if (level === 'error') this.error();\r\n      else this.other(level);\r\n    });\r\n    return log;\r\n  }\r\n  levels(level) {\r\n    const levels = _.isString(level) ? level.split(',') : level;\r\n    return levels\r\n    .map(i => i.replace(/\\s/g, ''));\r\n  }\r\n  error() {\r\n    log.on('error', function error() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args.map(i => log.color.red(i)));\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  other(level) {\r\n    log.on(level, function logger() {\r\n      /* eslint-disable no-console */\r\n      const args = Array.prototype.slice.call(arguments);\r\n      args.unshift(log.color.cyan('mrdoc'));\r\n      console.log.apply(console, args);\r\n      /* eslint-enable no-console */\r\n    });\r\n  }\r\n  /**\r\n   * Get the global instance of Log.\r\n   * @return {Log} - An instance of Log.\r\n   */\r\n  static global() {\r\n    log.color = Utils.Log.color;\r\n    return log;\r\n  }\r\n}\r\n\r\nmodule.exports = Log;\r\n"
            }
          },
          {
            "VyNO5--NRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "output.js",
                "ext": ".js",
                "name": "output"
              },
              "source": "'use strict';\nconst Source = require('./source');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst Parser = require('../parser/');\nconst Compiler = require('../compiler/');\nconst Vinyl = require('vinyl');\nconst Option = require('mr-doc-utils').Option;\n\nclass Output {\n  static handler(options, buffer) {\n    const opt = (new Option(options)).options();\n    return function (callback) {\n      Output.format(opt, buffer).forEach(Output.toStream(opt, this));\n      callback();\n    };\n  }\n  static format(options, buffer) {\n    const files = Source.create(buffer);\n    // Initalize Parser and Compiler\n    const parser = (new Parser(options)).factory();\n    const compiler = (new Compiler(options)).factory();\n    // DEBUG: Parser and Compiler\n    log.debug(Log.color.blue('Parser and compiler initialized:'), !!parser && !!compiler);\n    // DEBUG: Files\n    log.debug(Log.color.blue('Number of files: '), files.length);\n\n    const format = options.compiler().file.format;\n    if (format === 'md' || format === 'json') {\n      return files\n      .map(file => parser.parse(file))\n      .map(file => compiler.compile(file));\n    }\n    return buffer;\n  }\n\n  static toStream(options, context) {\n    const format = options.compiler().file.format;\n    const file = options.compiler().file;\n    return function (f) {\n      if (format === 'json' || format === 'md') {\n        this.push(new Vinyl({\n          path: `${file.name}.${file.format}`,\n          contents: new Buffer(f),\n        }));\n      } else if (format === 'html') {\n        this.push(f);\n      }\n    }.bind(context);\n  }\n}\n\nmodule.exports = Output;\n"
            }
          },
          {
            "NkHuqWW4Al": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\utils",
                "base": "source.js",
                "ext": ".js",
                "name": "source"
              },
              "source": "'use strict';\nconst ShortID = require('shortid');\nconst File = require('fs-extra');\nconst _ = require('lodash');\nconst Path = require('path');\n\nclass Source {\n  static create(files) {\n    // Process the files.\n    const result = files\n    .map(file => Source.processFile(file));\n    // Create references for each file.\n    const references = result\n    .map(file => Source.createReference(file));\n    // Process the references and attach it to each file.\n    return result\n    .map(file => Source.processReference(file, references));\n  }\n  static processFile(file) {\n    return {\n      id: ShortID.generate(),\n      cwd: file.cwd,\n      base: file.base.replace(file.cwd + Path.sep, ''),\n      path: Path.parse(file.path.replace(file.cwd + Path.sep, '')),\n      source: File.readFileSync(file.path, 'utf8'),\n      comments: undefined,\n    };\n  }\n  static createReference(file) {\n    return {\n      id: file.id,\n      cwd: file.cwd,\n      base: file.base,\n      path: file.path,\n      source: file.source,\n      comments: file.comments,\n    };\n  }\n  static processReference(file, references) {\n    return _.merge(file, {\n      ref: references.map(ref => ({ [ref.id]: _.omit(ref, 'id') })),\n    });\n  }\n}\n\nmodule.exports = Source;\n"
            }
          },
          {
            "NJLOqb-VRx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass ICompiler {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.compiler() : options;\n  }\n  /**\n   * Compile the comments into the desired output.\n   * @param  {Array<Object>} results - The files to compile.\n   * @return {*} - The compiled files.\n   */\n  /* eslint-disable no-unused-vars */\n  compile(comments) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = ICompiler;\n"
            }
          },
          {
            "NJw_q-bNAl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\engines",
                "base": "javascript.js",
                "ext": ".js",
                "name": "javascript"
              },
              "source": "'use strict';\n\nconst Babylon = require('babylon');\nconst Acorn = require('acorn');\nconst Espree = require('espree');\nconst ESCodeGen = require('escodegen');\nconst ESTraverse = require('estraverse');\nconst traverse = require('babel-traverse').default;\n\nconst opts = {\n  acorn: (version, comments, tokens) => ({\n    ecmaVersion: version,\n    locations: true,\n    onComment: comments,\n    onToken: tokens,\n    ranges: true,\n  }),\n  babylon: () => ({\n    allowImportExportEverywhere: true,\n    plugins: [\n      'jsx',\n      'flow',\n      'asyncFunctions',\n      'classConstructorCall',\n      'doExpressions',\n      'trailingFunctionCommas',\n      'objectRestSpread',\n      'decorators',\n      'classProperties',\n      'exportExtensions',\n      'exponentiationOperator',\n      'asyncGenerators',\n      'functionBind',\n      'functionSent',\n    ],\n    sourceType: 'module',\n  }),\n  espree: (version) => ({\n    attachComment: true,\n    comment: true,\n    ecmaFeatures: {\n      experimentalObjectRestSpread: true,\n      globalReturn: true,\n      impliedStrict: true,\n      jsx: true,\n    },\n    ecmaVersion: version,\n    loc: true,\n    range: true,\n    sourceType: 'module',\n    tokens: true,\n  }),\n};\n\nclass Engine {\n  constructor(options) {\n    this.options = options;\n    switch (this.options.engine) {\n      case 'acorn':\n        this.engine = Acorn;\n        break;\n      case 'espree':\n        this.engine = Espree;\n        break;\n      default:\n        this.engine = Babylon;\n        break;\n    }\n  }\n  parse(file) {\n    const comments = [];\n    const tokens = [];\n    try {\n      switch (this.options.engine) {\n        case 'acorn':\n          return ESCodeGen\n          .attachComments(this.engine.parse(file.source,\n            opts.acorn(this.options.version, comments, tokens)), comments, tokens);\n        case 'espree':\n          return this.engine.parse(file.source, opts.espree(this.options.version));\n        default:\n          return this.engine.parse(file.source, opts.babylon());\n      }\n    } catch (error) {\n      throw (new Error(error));\n    }\n  }\n  static traverse(options, ast, callback) {\n    switch (options.engine) {\n      case 'babylon':\n        traverse(ast, {\n          enter: (path) => {\n            const node = path.node;\n            callback(node);\n          } });\n        break;\n      default:\n        ESTraverse.traverse(ast, {\n          /* eslint-disable no-param-reassign */\n          enter: (node) => {\n            if (node.type === 'Program') {\n              node = node.body[0];\n            }\n            callback(node);\n          } });\n          /* eslint-enable no-param-reassign */\n        break;\n    }\n  }\n}\nmodule.exports = Engine;\n"
            }
          },
          {
            "V1duq--V0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers",
                "base": "interface.js",
                "ext": ".js",
                "name": "interface"
              },
              "source": "'use strict';\nclass IParser {\n  /**\n   * @constructor\n   * @param  {Object} options - The options for the compiler provided by mr-doc-utils/options\n   */\n  constructor(options) {\n    this.options = options.parser ? options.parser() : options;\n  }\n  /**\n   * Parses the sources' comments into the desired output.\n   * @param  {Array<Object>} results - The files to parse.\n   * @return {Array<Object>} - The parsed comments.\n   */\n  /* eslint-disable no-unused-vars */\n  parse(sources) {\n    // ...\n  }\n  /* eslint-enable no-unused-vars */\n}\n\nmodule.exports = IParser;\n"
            }
          },
          {
            "41FOcW-V0e": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\n\nclass HTML extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "NJ9O5ZbE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\json",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\nconst ICompiler = require('../interface');\nconst stringify = require('json-stringify');\nclass JSON extends ICompiler {\n  constructor(options) {\n    super(options);\n    this.results = [];\n  }\n  compile(comments) {\n    this.results = comments;\n    this.walk(this.results, function (comment) {\n      /* eslint-disable no-param-reassign */\n      delete comment.errors;\n      /* eslint-enable no-param-reassign */\n    });\n    return stringify(this.results, null, 2);\n  }\n  walk(comments, fn, options) {\n    comments.forEach(function (comment) {\n      fn(comment, options);\n      for (const scope in comment.members) {\n        if (comment.members.hasOwnProperty(scope)) {\n          this.walk(comment.members[scope], fn, options);\n        }\n      }\n    });\n  }\n}\n\nmodule.exports = JSON;\n"
            }
          },
          {
            "Nksu5--VRl": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "index.js",
                "ext": ".js",
                "name": "index"
              },
              "source": "'use strict';\n\nconst Doctrine = require('doctrine');\nconst IParser = require('../interface');\nconst Engine = require('../../engines/javascript');\nconst _ = require('lodash');\nconst Log = require('mr-doc-utils').Log;\nconst log = new Log();\nconst synonyms = require('./synonyms.js');\n\nclass JavaScript extends IParser {\n  constructor(options) {\n    super(options);\n    this.visited = {};\n    this.engine = new Engine(this.options);\n    this.comments = [];\n    this.results = [];\n  }\n  /**\n   * Parse the file.\n   * @param {Object} - The file to parse.\n   */\n  parse(file) {\n    this.file = file;\n    this.ast = this.engine.parse(this.file);\n    // DEBUG: AST\n    log.debug(Log.color.blue('Length of AST:'), this.ast.body.length);\n    [\n      { type: 'leadingComments', context: true },\n      { type: 'innerComments', context: false },\n      { type: 'trailingComments', context: false },\n    ].forEach(comment => this.walkComments(comment));\n    return this.results;\n  }\n  /**\n   * Walk the comments.\n   * @param {Object} - The comment type and context to walk.\n   */\n  walkComments(comment) {\n    Engine.traverse(this.options, this.ast, node => (node[comment.type] || [])\n        .filter(this.isJSDocComment)\n        .forEach(this.parseComment(node, comment.context)));\n  }\n  /**\n   * Parse the comment.\n   * @param {Node} - The current node.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseComment(node, includeContext) {\n    let range = (node.parent && node.parent) ? node.parent.range : [node.start, node.end];\n    range = !range ? node.range : range;\n    range = !range ? [node.start, node.end] : range;\n    const context = {\n      code: null,\n      file: this.file,\n      loc: _.extend({}, JSON.parse(JSON.stringify(node.loc))),\n      range: {\n        column: [node.loc.start.column, node.loc.end.column],\n        line: [node.loc.start.line, node.loc.end.line],\n      },\n    };\n    return (comment) => {\n      const key = JSON.stringify({ loc: comment.loc, range: comment.range });\n      if (!this.visited[key]) {\n        this.visited[key] = true;\n        if (includeContext) {\n          Object.defineProperty(context, 'ast', {\n            enumerable: false,\n            value: node,\n          });\n          context.code = this.file.source.substring.apply(this.file.source, range);\n        }\n        this.results.push(this.parseJSDoc(comment.value, comment.loc, context));\n      }\n    };\n  }\n  /**\n   * Parse the JSDoc comment.\n   * @param {String} - The comment to parse.\n   * @param {Location} - The comment location.\n   * @param {Boolean} - The truth value on whether to include the context.\n   */\n  parseJSDoc(comment, loc, context) {\n    const result = Doctrine.parse(comment, {\n      lineNumbers: true,\n      recoverable: true,\n      sloppy: true,\n      unwrap: true,\n    });\n    result.loc = loc;\n    result.context = context;\n    result.errors = [];\n    let i = 0;\n    while (i < result.tags.length) {\n      const tag = result.tags[i];\n      if (tag.errors) {\n        for (let j = 0; j < tag.errors.length; j++) {\n          result.errors.push({ message: tag.errors[j] });\n        }\n        result.tags.splice(i, 1);\n      } else i++;\n    }\n    return JavaScript.normalize(result);\n  }\n  /**\n   * Determine whether the comment is normalized.\n   * @param {String} - The comment to determine.\n   * @return {Boolean} - The truth value.\n   */\n  isJSDocComment(comment) {\n    const asterisks = comment.value.match(/^(\\*+)/);\n    return (comment.type === 'CommentBlock' ||\n      comment.type === 'Block')\n      && asterisks && asterisks[1].length === 1;\n  }\n  /**\n   * Normalize the comment tags.\n   * @param {Array} - The comment to normalize.\n   * @return {Array} - The comment containing normalized tags.\n   */\n  static normalize(comment) {\n    return _.assignIn({}, comment, {\n      tags: comment.tags.map(tag => {\n        let title = tag.title.toLowerCase();\n        const canonical = synonyms[title];\n        if (!canonical) {\n          switch (title[0]) {\n            case 'e':\n              if (title === 'extend') title = 'extends';\n              break;\n            case 'j':\n              if (title === 'jsfiddles') title = 'jsfiddle';\n              break;\n            default: break;\n          }\n        }\n        return canonical ? _.extend({}, tag, { title: canonical }) : tag;\n      }),\n    });\n  }\n}\n\nmodule.exports = JavaScript;\n"
            }
          },
          {
            "Ny3d5ZbECx": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\parser\\parsers\\javascript",
                "base": "synonyms.js",
                "ext": ".js",
                "name": "synonyms"
              },
              "source": "module.exports = {\r\n  arg: 'param',\r\n  argument: 'param',\r\n  constructor: 'class',\r\n  const: 'constant',\r\n  defaultvalue: 'default',\r\n  desc: 'description',\r\n  emits: 'fires',\r\n  exception: 'throws',\r\n  fileoverview: 'file',\r\n  func: 'function',\r\n  host: 'external',\r\n  linkcode: 'link',\r\n  linkplain: 'link',\r\n  virtual: 'abstract',\r\n  method: 'function',\r\n  overview: 'file',\r\n  prop: 'property',\r\n  return: 'returns',\r\n  var: 'member',\r\n};\r\n"
            }
          },
          {
            "416u9bZE0g": {
              "cwd": "C:\\Users\\Takeshi\\Documents\\GitHub\\mr-doc",
              "base": "src\\",
              "path": {
                "root": "",
                "dir": "src\\compiler\\compilers\\html\\engines",
                "base": "theme.js",
                "ext": ".js",
                "name": "theme"
              },
              "source": "'use strict';\n\nclass Theme {\n  constructor () {\n\n  }\n  compile () {\n\n  }\n}\n"
            }
          }
        ]
      },
      "loc": {
        "start": {
          "line": 121,
          "column": 2
        },
        "end": {
          "line": 140,
          "column": 3
        }
      },
      "range": {
        "column": [
          2,
          3
        ],
        "line": [
          121,
          140
        ]
      }
    }
  }
]
}
